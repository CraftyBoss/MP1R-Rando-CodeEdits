#pragma once

#include "types.h"

#include <Component/CGameObjectComponent.h>
#include <Types/TFunctorR.h>
#include <rstl/enum_bit_field.h>
#include <rstl/rc_ptr.hpp>
#include <rstl/reserved_list.h>

#include "CGameArea.h"

namespace NGameArea {
    enum ERoomType {
        UNK = 10,
    };
}
enum EAreaLoadType {};

template <typename A, typename B, typename C>
class TGOCSlotHandleMemFun;

class CSpecialCaseTouchVisitor;
class CPFArea;
struct CDataEnumValue;

#pragma pack(push, 1)
class CGameAreaManager {
private:
public:

    enum EBroadcastCurrentState {};
    enum EIgnorePreloaded {};

    CGameAreaManager(void);
    ~CGameAreaManager();

    void GetArea(CValueVersionId<uint,ushort,ushort,16u,16u> const&) const;
    void Area(CValueVersionId<uint,ushort,ushort,16u,16u> const&);
    void GetAreaByAssetId(CObjectId const&) const;
    void GetLoadedAreaByAssetId(CObjectId const&) const;
    void GetLoadingAreaByAssetId(CObjectId const&) const;
    void GetUnloadingAreaByAssetId(CObjectId const&) const;
    void AreaByAssetId(CObjectId const&);
    void LoadedAreaByAssetId(CObjectId const&);
    void LoadingAreaByAssetId(CObjectId const&);
    void UnloadingAreaByAssetId(CObjectId const&);
    void GetAreaFromListByAssetId(rstl::reserved_list<rstl::ncrc_ptr<CGameArea>,32> const&,CObjectId const&) const;
    void AreaFromListByAssetId(rstl::reserved_list<rstl::ncrc_ptr<CGameArea>,32> &,CObjectId const&);
    void GetLoadedOrLoadingAreaByAssetId(CObjectId const&) const;
    bool IsAreaConnectionOpen(CStateManager const&,CValueVersionId<uint,ushort,ushort,16u,16u>,CValueVersionId<uint,ushort,ushort,16u,16u>) const;
    int GetCurrentAreaId(void);
    CObjectId& GetCurrentAreaAssetId(void) const;
    bool IsOrParentOfCurrentAreaAssetId(CObjectId const&) const;
    bool IsOrParentOfComparisonAreaAssetId(CObjectId const&,CObjectId const&) const;
    void CurrentArea(void);
    void GetCurrentArea(void) const;
    void SetCurrentArea(CStateManager &,CValueVersionId<uint,ushort,ushort,16u,16u> const&);
    void CanLoadArea(CObjectId const&);
    void BeginAreaLoad(CObjectId const&,EAreaLoadType);
    void AllocateAreaUniqueId(void);
    void BeginAreaUnload(CValueVersionId<uint,ushort,ushort,16u,16u> const&);
    void BeginUnloadAreasByType(rstl::enum_bit_field<NGameArea::ERoomType,uint,(NGameArea::ERoomType)10> const&,rstl::growable_reserved_vector<CObjectId,4,rstl::rmemory_allocator> const&,CGameAreaManager::EIgnorePreloaded);
    void BeginUnloadAllPreloadedAreas(void);
    void ReloadAreaIfStateChanged(CStateManager &,CObjectId const&);
    void UpdateAllAreasUnload(CStateManager &,float);
    void UpdateAreaLoading(CStateManager &,float);
    void UpdateLoadedAreaList(CStateManager &);
    void UpdateAreaUnloading(CStateManager &,float);
    void UpdateAreaLoadingPriorities(CStateManager &);
    void DeallocateAreaUniqueId(CValueVersionId<uint,ushort,ushort,16u,16u>);
    bool IsAreaAndNeighborAreaLoaded(CValueVersionId<uint,ushort,ushort,16u,16u> const&) const;
    void HasAnyActiveChildAreas(CObjectId const&);
    void HasAnyActiveAreasByType(rstl::enum_bit_field<NGameArea::ERoomType,uint,(NGameArea::ERoomType)10> const&,CGameAreaManager::EIgnorePreloaded);
    void HasAnyLoadingAreaByType(rstl::enum_bit_field<NGameArea::ERoomType,uint,(NGameArea::ERoomType)10>);
    void HasAnyUnloadingAreasByType(rstl::enum_bit_field<NGameArea::ERoomType,uint,(NGameArea::ERoomType)10>);
    void AddBeginAreaLoadingCallback(CObjectId const&,TFunctorR<void,CStateManager &,CGameArea &> const&);
    void RemoveBeginAreaLoadingCallback(CObjectId const&,TFunctorR<void,CStateManager &,CGameArea &> const&);
    void NotifyBeginAreaLoading(CStateManager &,CObjectId const&,CValueVersionId<uint,ushort,ushort,16u,16u>);
    void ConnectToAreaCreatedSignal(TFunctorR<void,CGameArea &>,CGameAreaManager::EBroadcastCurrentState);
    void ConnectToCurrentAreaChangedSignal(TFunctorR<void,CStateManager &>);
    void ConnectPathFindAreaUnloaded(TFunctorR<void,CStateManager &,CPFArea const&> const&);
    void RemovePathFindArea(CStateManager &,int);
    void GetFirstEntityUniqueIdForDataEnum(CDataEnumValue const&) const;
    void GetAreaFromListByAreaId(rstl::reserved_list<rstl::ncrc_ptr<CGameArea>,32> const&,CValueVersionId<uint,ushort,ushort,16u,16u>) const;
    void ForEachArea_BeginFrame(CStateManager &,float);
    void ForEachArea_BeforeThink(CStateManager &,float);
    void ForEachArea_Think(CStateManager &,float);
    void ForEachArea_Think_Composed(CStateManager &,float,TFunctorR<void,TGOCSlotHandleMemFun<CGameObjectComponent,CStateManager &,float const> const&,CStateManager &,float const> const&);
    void ForEachArea_AfterThink(CStateManager &,float);
    void ForEachArea_BeforePhysics(CStateManager &,float);
    void ForEachArea_UpdatePhysics(CStateManager &,float);
    void ForEachArea_AfterPhysics(CStateManager &,float);
    void ForEachArea_SpecialCaseTouch(CStateManager &,CSpecialCaseTouchVisitor &);
    void ForEachArea_BeforeTouch(CStateManager &);
    void ForEachArea_AfterTouch(CStateManager &);
    void ForEachArea_CinematicStarted(CStateManager &);
    void ForEachArea_BeforeUpdateDisplayManager(CStateManager &,float);
    void ForEachArea_AfterUpdateDisplayManager(CStateManager &,float);
    void ForEachArea_UpdateEffects(CStateManager const&,float,TFunctorR<void,TGOCSlotHandleMemFun<CGameObjectComponent,CStateManager const&,float const> const&,CStateManager const&,float const> const&);
    void ForEachArea_BeforeUpdateRenderState(CStateManager &);
    void ForEachArea_UpdateRenderState(CStateManager const&);
    void ForEachArea_UpdateEffectsManager(CStateManager &,float);
    void ForEachArea_UpdateDecalManager(CStateManager &,float);
    void ForEachArea_SetInventoryCallback(CStateManager &,CDataEnumValue const&,float,float);
    void ForEachArea_SetInventoryCapacityCallback(CStateManager &,CDataEnumValue const&,float,float);
    void SetRandomSeed(uint);
    
    CGameArea *mCurArea;
    void* field_8;
    char *field_10;
    char *field_18;
    char *field_20;
    char *field_28;
    char *field_30;
    char *field_38;
    int field_40;
    char gap_44[4];
    char *field_48;
    char gap_50[32];
    char *field_70;
    char gap_78[32];
    char *field_98;
    char gap_A0[32];
    char *field_C0;
    char gap_C8[32];
    char *field_E8;
    char gap_F0[32];
    char *field_110;
    char gap_118[32];
    char *field_138;
    char gap_140[32];
    char *field_160;
    char gap_168[32];
    char *field_188;
    char gap_190[32];
    char *field_1B0;
    char gap_1B8[32];
    char *field_1D8;
    char gap_1E0[32];
    char *field_200;
    char gap_208[32];
    char *field_228;
    char gap_230[32];
    char *field_250;
    char gap_258[32];
    char *field_278;
    char gap_280[32];
    char *field_2A0;
    char gap_2A8[32];
    char *field_2C8;
    char gap_2D0[32];
    char *field_2F0;
    char gap_2F8[32];
    char *field_318;
    char gap_320[32];
    char *field_340;
    char gap_348[32];
    char *field_368;
    char gap_370[32];
    char *field_390;
    char gap_398[32];
    char *field_3B8;
    char gap_3C0[32];
    char *field_3E0;
    char gap_3E8[32];
    char *field_408;
    char gap_410[32];
    char *field_430;
    char gap_438[32];
    char *field_458;
    char gap_460[32];
    char *field_480;
    char gap_488[32];
    char *field_4A8;
    char gap_4B0[32];
    char *field_4D0;
    char gap_4D8[32];
    char *field_4F8;
    char gap_500[32];
    void* field_520;
    char gap_528[32];
    char *field_548;
    char *field_550;
    char *field_558;
    char *field_560;
    char *field_568;
    char *field_570;
    int field_578;
    char gap_57C[4];
    char *field_580;
    char gap_588[32];
    char *field_5A8;
    char gap_5B0[32];
    char *field_5D0;
    char gap_5D8[32];
    char *field_5F8;
    char gap_600[32];
    char *field_620;
    char gap_628[32];
    char *field_648;
    char gap_650[32];
    char *field_670;
    char gap_678[32];
    char *field_698;
    char gap_6A0[32];
    char *field_6C0;
    char gap_6C8[32];
    char *field_6E8;
    char gap_6F0[32];
    char *field_710;
    char gap_718[32];
    char *field_738;
    char gap_740[32];
    char *field_760;
    char gap_768[32];
    char *field_788;
    char gap_790[32];
    char *field_7B0;
    char gap_7B8[32];
    char *field_7D8;
    char gap_7E0[32];
    char *field_800;
    char gap_808[32];
    char *field_828;
    char gap_830[32];
    char *field_850;
    char gap_858[32];
    char *field_878;
    char gap_880[32];
    char *field_8A0;
    char gap_8A8[32];
    char *field_8C8;
    char gap_8D0[32];
    char *field_8F0;
    char gap_8F8[32];
    char *field_918;
    char gap_920[32];
    char *field_940;
    char gap_948[32];
    char *field_968;
    char gap_970[32];
    char *field_990;
    char gap_998[32];
    char *field_9B8;
    char gap_9C0[32];
    char *field_9E0;
    char gap_9E8[32];
    char *field_A08;
    char gap_A10[32];
    char *field_A30;
    char gap_A38[32];
    void* field_A58;
    char gap_A60[32];
    char *field_A80;
    char *field_A88;
    char *field_A90;
    char *field_A98;
    char *field_AA0;
    char *field_AA8;
    int field_AB0;
    char gap_AB4[4];
    char *field_AB8;
    char gap_AC0[32];
    char *field_AE0;
    char gap_AE8[32];
    char *field_B08;
    char gap_B10[32];
    char *field_B30;
    char gap_B38[32];
    char *field_B58;
    char gap_B60[32];
    char *field_B80;
    char gap_B88[32];
    char *field_BA8;
    char gap_BB0[32];
    char *field_BD0;
    char gap_BD8[32];
    char *field_BF8;
    char gap_C00[32];
    char *field_C20;
    char gap_C28[32];
    char *field_C48;
    char gap_C50[32];
    char *field_C70;
    char gap_C78[32];
    char *field_C98;
    char gap_CA0[32];
    char *field_CC0;
    char gap_CC8[32];
    char *field_CE8;
    char gap_CF0[32];
    char *field_D10;
    char gap_D18[32];
    char *field_D38;
    char gap_D40[32];
    char *field_D60;
    char gap_D68[32];
    char *field_D88;
    char gap_D90[32];
    char *field_DB0;
    char gap_DB8[32];
    char *field_DD8;
    char gap_DE0[32];
    char *field_E00;
    char gap_E08[32];
    char *field_E28;
    char gap_E30[32];
    char *field_E50;
    char gap_E58[32];
    char *field_E78;
    char gap_E80[32];
    char *field_EA0;
    char gap_EA8[32];
    char *field_EC8;
    char gap_ED0[32];
    char *field_EF0;
    char gap_EF8[32];
    char *field_F18;
    char gap_F20[32];
    char *field_F40;
    char gap_F48[32];
    char *field_F68;
    char gap_F70[32];
    void* field_F90;
    char gap_F98[32];
    void* field_FB8;
    void* field_FC0;
    void* field_FC8;
    void* field_FD0;
    void* field_FD8;
    void* field_FE0;
    void* field_FE8;
    void* field_FF0;
    void* field_FF8;
    void* field_1000;
    void* field_1008;
    void* field_1010;
    void* field_1018;
    void* field_1020;
    void* field_1028;
    void* field_1030;
    short field_1038;
    void* field_103A;
    char gap_1042[6];
    void* field_1048;
    int field_1050; // CRandom16
    char gap_1054[4];
    int field_1058;
    char field_105C[0x14]; // CPFAreaManager
    char *field_1070;
    char *field_1078;
    char *field_1080;
    char *field_1088;
    int field_1090;
    char gap_1094[4];
    char *field_1098;
    char *field_10A0;
    char *field_10A8;
    char *field_10B0;
    int field_10B8;
    char gap_10BC[4];
    char *field_10C0;
    char *field_10C8;
    char *field_10D0;
    char *field_10D8;
    int field_10E0;
};
#pragma pack(pop)